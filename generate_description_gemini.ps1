# This PowerShell script automates the generation of photo descriptions using the Gemini CLI.
# It processes image files in the 'web/photos' directory, generates a descriptive text for each,
# and saves the output to a JSON file. The script includes logic for retrying failed attempts
# and handling rate limits.
#
# This script was originally generated by AI and has been modified.

# --- Configuration ---
$OutputFile = "description.json"
$PromptTemplate = "Describe this photo of Elliott the dog in 1-2 sentences. Elliott is the yellow lab, Renzo is a German Shepherd. Make it heartwarming and slightly humorous. Return ONLY the description text, no extra formatting or explanations. @{0}"
$MAX_RETRIES = 3
$RETRY_DELAY = 5  # seconds
$RATE_LIMIT_DELAY = 60  # seconds to wait when hitting rate limits
$SUCCESS_DELAY = 2  # seconds between successful requests

# --- Script ---

# Change to the photos directory
Set-Location "web\photos"

# Initialize empty hashtable for descriptions
$descriptions = @{}
$failedPhotos = @()
$retryCount = @{}

# Check if description.json exists and load existing data
if (Test-Path $OutputFile) {
    try {
        $existingJson = Get-Content $OutputFile -Raw | ConvertFrom-Json
        # Convert to hashtable for easier manipulation
        $existingJson.PSObject.Properties | ForEach-Object {
            $descriptions[$_.Name] = $_.Value
        }
        Write-Host "Loaded existing descriptions from $OutputFile" -ForegroundColor Yellow
    } catch {
        Write-Host "Could not load existing $OutputFile, starting fresh" -ForegroundColor Yellow
    }
}

# Dynamically get all image files from the photos directory
$allPhotos = Get-ChildItem -Path "." -File | Where-Object {
    $_.Extension -match '\.(jpg|jpeg|png|gif)$' -and $_.Name -ne $OutputFile
} | Select-Object -ExpandProperty Name | Sort-Object

# Filter out photos that already have descriptions
$photos = $allPhotos | Where-Object { -not $descriptions.ContainsKey($_) }

Write-Host "Found $($allPhotos.Count) total photos, $($photos.Count) missing descriptions..." -ForegroundColor Cyan
if ($photos.Count -eq 0) {
    Write-Host "All photos already have descriptions! Exiting..." -ForegroundColor Green
    exit 0
}

function Save-Descriptions {
    param($descriptions)
    try {
        $orderedDescriptions = [ordered]@{}
        $descriptions.GetEnumerator() | Sort-Object Name | ForEach-Object {
            $orderedDescriptions[$_.Key] = $_.Value
        }
        $jsonOutput = $orderedDescriptions | ConvertTo-Json -Depth 10
        $jsonOutput | Set-Content -Path $OutputFile -Encoding UTF8
        return $true
    } catch {
        Write-Host "  ‚úó Error saving JSON: $_" -ForegroundColor Red
        return $false
    }
}

function Process-Photo {
    param($photo)

    try {
        Write-Host "Processing $photo..." -ForegroundColor Green

        # Call Gemini CLI and capture output
        $prompt = [string]::Format($PromptTemplate, $photo)
        $description = & gemini $prompt 2>$null

        # Clean up the description
        $cleanDescription = ($description | Out-String).Trim()

        if ($cleanDescription -and $cleanDescription.Length -gt 0 -and $cleanDescription -notmatch "error|failed|could not|unable to") {
            $descriptions[$photo] = $cleanDescription
            Write-Host "‚úì Added description for $photo" -ForegroundColor Green

            # Save JSON after each successful description
            if (Save-Descriptions $descriptions) {
                Write-Host "  ‚Üí Saved to $OutputFile ($($descriptions.Count) total)" -ForegroundColor Cyan
            }

            return $true
        } else {
            return $false
        }
    } catch {
        Write-Host "‚úó Error processing $photo`: $_" -ForegroundColor Red
        return $false
    }
}

# Process all photos with retry logic
foreach ($photo in $photos) {
    # Double-check if we already have a description (shouldn't happen after filtering above)
    if ($descriptions.ContainsKey($photo)) {
        Write-Host "Skipping $photo (already has description)..." -ForegroundColor Gray
        continue
    }

    # Initialize retry count for this photo
    $retryCount[$photo] = 0
    $success = $false

    # Try processing the photo with retries
    while (-not $success -and $retryCount[$photo] -lt $MAX_RETRIES) {
        if ($retryCount[$photo] -gt 0) {
            Write-Host "Retrying $photo (attempt $($retryCount[$photo] + 1)/$MAX_RETRIES)..." -ForegroundColor Yellow
            Start-Sleep -Seconds $RETRY_DELAY
        }

        $success = Process-Photo $photo
        $retryCount[$photo]++

        if ($success) {
            Start-Sleep -Seconds $SUCCESS_DELAY
            break
        } else {
            Write-Host "‚úó No description received for $photo (attempt $($retryCount[$photo]))" -ForegroundColor Red

            # Check if this might be a rate limit issue
            if ($retryCount[$photo] -eq 2) {
                Write-Host "‚è±Ô∏è Possible rate limit hit. Waiting $RATE_LIMIT_DELAY seconds..." -ForegroundColor Yellow
                Start-Sleep -Seconds $RATE_LIMIT_DELAY
            }
        }
    }

    # If all retries failed, add to failed list
    if (-not $success) {
        $failedPhotos += $photo
        Write-Host "‚ö†Ô∏è $photo failed after $MAX_RETRIES attempts, adding to retry queue" -ForegroundColor Magenta
    }
}

# Process failed photos one more time after a longer delay
if ($failedPhotos.Count -gt 0) {
    Write-Host "`nüîÑ Processing $($failedPhotos.Count) failed photos after extended delay..." -ForegroundColor Cyan
    Start-Sleep -Seconds ($RATE_LIMIT_DELAY * 2)

    $stillFailed = @()

    foreach ($photo in $failedPhotos) {
        if ($descriptions.ContainsKey($photo)) {
            continue  # Skip if somehow got processed already
        }

        Write-Host "Final attempt for $photo..." -ForegroundColor Yellow
        $success = Process-Photo $photo

        if ($success) {
            Start-Sleep -Seconds $SUCCESS_DELAY
        } else {
            $stillFailed += $photo
        }
    }

    if ($stillFailed.Count -gt 0) {
        Write-Host "`n‚ùå Still failed photos:" -ForegroundColor Red
        $stillFailed | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }

        # Save failed photos to a text file
        $stillFailed | Set-Content -Path "failed_photos.txt"
        Write-Host "`nüíæ Failed photos saved to failed_photos.txt for manual retry" -ForegroundColor Yellow
    }
}

Write-Host "`n‚úÖ Processing complete!" -ForegroundColor Green
Write-Host "Successfully processed: $($descriptions.Count) photos" -ForegroundColor Green
Write-Host "Failed photos: $($stillFailed.Count)" -ForegroundColor $(if ($stillFailed.Count -eq 0) { "Green" } else { "Red" })
Write-Host "Results saved to: $OutputFile" -ForegroundColor Cyan